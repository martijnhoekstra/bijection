// This is a generator for java methods to forward to, as a workaround for
// scala bug#11770
//
// Run this generator like a script:
// scala GeneratorWorkaroundJava.scala > ../src/main/scala-2.13+/com/twitter/bijection/clojure/Workaround11770.java

def conversionN(n: Int) = {
  val intypes = (1 to n).map(i => "I" + i.toString).toList
  val invalues = intypes.map(_.toLowerCase)
  val intv = intypes.zip(invalues).map{ case (t, v) => s"$t $v"}
  val inobjv = invalues.map(v => s"Object $v")
  val casts = intypes.zip(invalues).map{ case (t, v) => s"($t)$v"}
  def render(args: List[String]) = args.mkString(", ")
  
s"""
  public static final <O, ${render(intypes)}> Bijection<Function$n<${render(intypes)}, O>, IFn> function${n}ToIFn() {
    return new AbstractBijection<Function$n<${render(intypes)}, O>, IFn>() {
      public final AFn apply(Function${n}<${render(intypes)}, O> fna) {
        final Function${n}<${render(intypes)}, O> fn = fna;
        return new AFn() {
          public final Object invoke(${render(inobjv)}) {
            return (Object)fn.apply(${render(casts)});
          }
        };
      }

      public final Function${n}<${render(intypes)}, O> invert(IFn fna) {
        final IFn fn = fna;
        return new Function${n}<${render(intypes)}, O>(){
          public final O apply(${render(intv)}) {
            return (O)fn.invoke(${render(invalues)});
          }
        };
      }
    };
  }
"""
}

val fileContents = s"""
/*
Copyright 2012 Twitter, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */

package com.twitter.bijection.clojure;
import clojure.lang.AFn;
import clojure.lang.IFn;
import com.twitter.bijection.AbstractBijection;
import com.twitter.bijection.Bijection;

${(0 to 22).map(n => s"import scala.Function${n};").mkString("\n")}

public class Workaround11770 {

  public static final <O> Bijection<Function0<O>, IFn> function0ToIFn() {
    return new AbstractBijection<Function0<O>, IFn>() {
      public final AFn apply(Function0<O> fna) {
        final Function0<O> fn = fna;
        return new AFn() {
          public final Object invoke() {
            return (Object)fn.apply();
          }
        };
      }

      public Function0<O> invert(IFn fna) {
        final IFn fn = fna;
        return new Function0<O>(){
          public final O apply() {
            return (O)fn.invoke();
          }
        };
      }
    };
  }

${(1 to 22).map(conversionN).mkString("\n\n")}

}""";

println("// Autogenerated code DO NOT EDIT BY HAND")
println("// Generated by bijection-clojure/codegen/GeneratorWorkaroundJava.scala")
println(fileContents)